# 类加载子系统 Class Loader SubSystem

## 概述

在 ==class 文件== 中描述了 ==类== 的各种信息，但是这些信息都必须被 “弄” 到虚拟机中之后才能使用。JVM 是如何将这些 class 文件 “弄” 到内存里的？

> class 文件：并非特指磁盘上的一个文件，而是一串二进制字节流。
>
> 很多人理解的是 HelloWorld.java 编译得到 HelloWorld.class 文件，这有点狭隘。（但是按照该思路来学习理解也无伤大雅）
>
> 可能是从网络中请求回来的，也可能是数据库加载过来的，也可能是使用代码动态产生的。

> 类：并非特指 public class User{} 这种类，也可能是 public interface XXX{} 接口
>
> 很多人理解的 类 就是单纯的 public class XXX{} 类型，这有点狭隘。（但是按照该思路来学习理解也无伤大雅）
>
> **一个 class 文件表示的可能是：类 class，接口 interface，枚举 enum，记录 record，注解 @interface**（如果有特殊场景需要分开描述，会特别说明）



## 类加载步骤

![image-20230603102715836](https://attach.blog.wen7.online/202306031027956.png)

一个类从加载到 JVM 内存中到从内存中卸载，要经历以下的的生命周期：

1. 加载
2. 连接
   1. 验证
   2. 准备
   3. 解析
3. 初始化
4. 使用
5. 卸载

> ==按照这 5 个步骤顺序开始，但不一定顺序执行==
>
> 比如 【解析】和【初始化】，一般情况是先解析后初始化，但是具体虚拟机实现可能有所不同，可能会将解析延迟到初始化之后，也有可能解析的过程依赖初始化的某些准备工作。所以【解析】和【初始化】可能是双螺旋的交替进行。
>
> **不过记住【加载】【验证】【准备】【解析】【初始化】【使用】【卸载】就可以了**

| 类型生命周期 |   加载   |         验证         |        准备        |             解析             |     初始化     |        使用        | 卸载 |
| :----------: | :------: | :------------------: | :----------------: | :--------------------------: | :------------: | :----------------: | :--: |
| 面见网友过程 | 网上聊天 | 面见网友是否盘正条顺 | 吃个晚饭，看个电影 | 开房谈心，层层剥开，袒诚相对 | 人类诞生的起源 | 谈恋爱（最长阶段） | 分手 |

