图
===

图的概念
---

大家都用过微信，生活中每个人都是有朋友的

你的好友：牛大，王二，张三，李四，赵五

牛大又有好友：Jack，Tom，Rose

Jack 又认识 Tom，Rose 又认识赵五

这样的关系网就如下，就是数据结构中的 **图 Graph**

<img src="https://attach.blog.wen7.online/image-20220525102121645.png" alt="image-20220525102121645" style="zoom:80%;" />



基本术语
---

| 术语 |  英文  | 解释               |
| :--: | :----: | ------------------ |
| 顶点 | vertex | 基本单元，每个节点 |
|  边  |  edge  | 顶点之间的关联     |
| 权重 | weight | 边的值             |

假设 ABCDE 是5个公交站点，公交站点之间的距离分别如边上数字所示

下图就称为：**带权图**

![image-20220525102718401](https://attach.blog.wen7.online/image-20220525102718401.png)



有向图/无向图
---

例如QQ：如果 A删掉了B，B也看不见A了，两人之间的关系是相互的，这种没有方向区分的称为**无向图**

例如微信：如果C删掉了A，A还是能看见C在好友列表，只是消息发不出去了，这种有方向区分的称为**有向图**

![image-20220525103408194](https://attach.blog.wen7.online/image-20220525103408194.png)



物理存储
---

以上都是逻辑概念，在内存中如何存储呢？图的存储结构有很多

### 邻接矩阵

![image-20220525104256226](https://attach.blog.wen7.online/image-20220525104256226.png)

如图所示，顶点自身到自身使用 0 表示

```shell
# 因为 0 和其他结点都有关联
V0-V0 使用 arr[0][0] = 0 		#结点自身关系为 0
V0-V1 使用 arr[0][1] = 1 
V0-V2 使用 arr[0][2] = 1 
V0-V3 使用 arr[0][3] = 1 
# 结点 2 只与 0和3有关联
V2-V0 使用 arr[2][0] = 1 
V2-V1 使用 arr[2][1] = 0 
V2-V2 使用 arr[2][2] = 0 		#结点自身关系为 0
V2-V3 使用 arr[2][3] = 1 
```

- 邻接矩阵从左上到右下的对角线必定都是0，因为顶点与自身是没有连接的
- 无向图的邻接矩阵的根据左上右下对角线对称的，因为 0-1 有关联，1-0 也必定有关联



![image-20220525105228252](https://attach.blog.wen7.online/image-20220525105228252.png)

- 有向图的邻接矩阵就不是对称的了，0 可以到 1，但是 1 不可以到 0



邻接矩阵的优点：

- 简单直观

邻接矩阵的缺点：

- 浪费内存，如果一个图有1000个顶点，只有20个顶点有关联，却得建立一个 1000 x 1000 的二维数组（这种数组又被称为稀疏数组），浪费



### 邻接表与逆邻接表

![image-20220525110010660](https://attach.blog.wen7.online/image-20220525110010660.png)

使用**邻接表**来解决邻接矩阵的占用空间问题，类似 Hash

想要查找 0 顶点是否能够到达顶点 1，只要遍历顶点0，后面的链表是否存在 1 即可

但是如果想查找哪些顶点能够到达顶点2 呢？使用**逆邻接表**

![image-20220525110526013](https://attach.blog.wen7.online/image-20220525110526013.png)

### 十字链表

有向图某顶点能够到达哪些顶点使用，邻接表

有向图哪些顶点能够到达某顶点使用，逆邻接表

但是如果创建2个表就太浪费了，刚好可以一左一右，使用十字链表

![image-20220525111109733](https://attach.blog.wen7.online/image-20220525111109733.png)