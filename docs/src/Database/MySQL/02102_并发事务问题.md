并发事务问题
===

当单线程的时候，是不会涉及到隔离性的，在并发环境下，多个事务同时发生，会出现以下问题：

- 脏读（Dirty read）
    - 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

- 丢失修改（Lost to modify）
    - 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

- 不可重复读（Unrepeatable read）
    - 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

- 幻读（Phantom read）
    - 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。




脏读
---

假设现在有两个线程 A 和 B，分别做以下方框内的事，【开启事务】【执行SQL 语句】【提交或回滚】

![image-20220628132650565](https://attach.blog.wen7.online/image-20220628132650565.png)

假设两个线程的执行顺序如下

1. A 线程开启事务
2. A 线程执行 SQL 语句1，查询了张三的余额为 1000
3. A 线程执行 SQL 语句2，查询了李四的余额为 1000
4. A 线程执行 SQL 语句3，给张三的余额减100，现在张三的余额为 900，但是 A 线程还没有提交或回滚
5. B 线程此时进来开启事务
6. B 线程执行 SQL 语句1，查询了张三的余额为 900。

==B 线程读取到了 A 线程还没提交的数据 900，如果 B 线程使用了该 900 减 300，万一 A 线程后续是回滚了，A 线程回滚到了 1000，那么 B 线程使用 900-300=600 该计算结果就是错误的==

脏读：B 线程读取到了 A 线程 **修改了但是还未提交** 的数据。



丢失修改
---

![image-20220628132650565](https://attach.blog.wen7.online/image-20220628132650565.png)

假设两个线程的执行顺序如下

1. A 线程开启事务
2. A 线程执行 SQL 语句1，查询了张三的余额为 1000
3. A 线程执行 SQL 语句2，查询了李四的余额为 1000
4. B 线程此时进来开启事务
5. B 线程执行 SQL 语句1，查询了张三的余额为 1000【B线程以为张三的余额为 1000】
6. B 线程执行 SQL 语句2，查询了李四的余额为 1000
7. A 线程执行 SQL 语句3，给张三的余额减100，此时余额为 900
8. B 线程执行 SQL 语句3，给张三的余额减300，此时的余额为 700【因为B线程读取的是 1000，使用 1000-300=700】

==A 线程先修改的减100，被 B 线程的减300 覆盖了，两个线程都提交之后，最终张三的钱为 700，A线程丢失了修改==

丢失修改：A 读取某个值时，B 也读取了该值，A 修改了该值，B 也修改了该值，导致A 的修改丢失



不可重复读（读不一致）
---

![image-20220628142140046](https://attach.blog.wen7.online/image-20220628142140046.png)

假设两个线程的执行顺序如下

1. A 线程开启事务
2. A 线程执行 SQL 语句1，查询了张三的余额为 1000【A线程第一次读】
3. B 线程此时进来开启事务
4. B 线程执行 SQL 语句1，查询了张三的余额为 1000
5. B 线程执行 SQL 语句2，查询了李四的余额为 1000
6. B 线程执行 SQL 语句3，给张三的余额减300，此时余额为 700
7. A 线程执行 SQL 语句2，查询了张三的余额为 700【A线程第二次读】

==A 线程在自身的事务内，多次读张三余额，结果由于 B 线程修改了该数据，导致 A 线程多次读的结果不一样==

不可重复读：在 A 事务内，由于 B 线程修改了某个值，导致 A 线程多次读取的值不一样

```markdown
# 博主个人见解，仅做参考，欢迎指正
不可重复读的翻译非常不好,对于初学者不便于理解
个人更倾向于翻译成 读不一致
即,同一个线程内,读的两次数据不重复,不一样,两次读取本应该是相同的,结果不同
```



幻读
---

![image-20220628144447445](https://attach.blog.wen7.online/image-20220628144447445.png)

假设两个线程的执行顺序如下

1. A 线程开启事务
2. B 线程开启事务
3. A 线程执行 SQL 语句1，查询了 money=1000 的人数【2个】
4. B 线程执行 SQL 语句1，添加了王五，并且 money=1000
5. A 线程执行 SQL 语句2，查询了 money=1000 的人数【3个】
6. B 线程执行 SQL 语句2，添加了赵六，并且 money=1000
7. A 线程执行 SQL 语句3，查询了 money=1000 的人数【4个】



==A 线程查询数据的时候，由于 B 线程在添加或者删除数据，导致 A 读取的记录数不一样==

幻读：A 线程读取数据，由于 B 线程添加或删除数据，导致 A 线程发现多了不存在的记录，就像发生了幻觉一样。





常见疑问
---

幻读和不可重复读的区别？

```markdown
不可重复读侧重于某一条记录，多次读取的结果不一样
幻读侧重于记录变多或变少
```

