MySQL 数据结构对比
===

## 全表扫描

| id（学号） | name（姓名） | rank（排名） | desc（描述） |
| :--------: | :----------: | :----------: | :----------: |
|     1      |     牛大     |      34      |              |
|     2      |     王二     |      77      |              |
|     3      |     张三     |      5       |              |
|     4      |     李四     |      91      |              |
|     5      |     赵五     |      22      |              |
|     6      |     劳六     |      89      |              |
|     7      |     田七     |      23      |              |
|     8      |     苟八     |      13      |              |
|    ...     |     ...      |     ...      |     ...      |

想要查询 rank 排名等于 89 的学生，如果没有索引，得从第一行开始，一行一行的拿出数据判断 rank 是否等于 89。这就是 ==全表扫描==，复杂度为 O(n)。



## Hash

Hash 一般是数组 + 链表的情况，比如 Java 语言中的 HashMap 就使用 数组+链表来实现 Hash 表（在 JDK 8 以后，HashMap 如果链表长度超过 8，还会升级成红黑树）

对某一列做哈希运算，然后得到一张 Hash表，Hash表保存的就是数据的地址。

![image-20220706002137561](https://attach.blog.wen7.online/20220706002137.png)

- 如果 Hash 冲突很高的数据，不适合对情况较少的列做 hash，比如性别，年龄。
  - 如果对性别做 hash，性别无非就是男，女，那么 hash 表的数组就只有2个数据，每个链表上的数据会非常多



### 使用场景

- 为超长的键创建哈希索引

  - 列值太长，导致索引体积过大，导致结点索引数量变少，查询速度会受到影响

  - 思路：增加额外 Hash 列，将列值映射成哈希值，对哈希值再进行索引

  - ```mysql
    select *
    from test_table
    where 列B = hash('https://www.baidu.com/s?wd=%E5%8C%97%E4%BA%AC%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E4%B8%80%E5%91%A8')
    and 列A = 'https://www.baidu.com/s?wd=%E5%8C%97%E4%BA%AC%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E4%B8%80%E5%91%A8'
    ```

  ![image-20220706003434976](https://attach.blog.wen7.online/20220706003435.png)
  
  

### 适用的存储引擎

| 存储引擎  |   InnoDB   | MyISAM | Memory |
| :-------: | :--------: | :----: | :----: |
| Hash 索引 | ==不支持== | 不支持 |  支持  |

- ==InnoDB 是不支持 Hash 的，但是提供了 自适应 Hash 索引==

- ```mysql
  # 查看是否开启 自适应Hash,默认开启
  mysql> show variables like 'innodb_adaptive_hash_index';
  ```

  ![image-20230312160118581](https://attach.blog.wen7.online/20230312160120.png)

  比如查询数据 `select * from sys_user where id_card=410204199101091372`，我们先去查找 身份证号索引的 B+树，查找到叶子结点找到该数据的主键，然后回表去主键B+树查找各条数据，然后找到叶子结点加载数据页，这一通查找如果是经常做的，innodb 会将这些数据页的地址加入到 hash 表，以后再进行该查询，直接去 hash 表里查找数据页地址。
  
  |             查询条件              | B+树                                                         | 数据页地址 |
  | :-------------------------------: | ------------------------------------------------------------ | ---------- |
  | where  id_card=410204199101091372 | 先查身份证号B+树，获取主键，回表查询主键 B+树，获取数据页地址 | 0x97 A2    |
  | where  id_card=350305199101246843 |                                                              | 0xB4 67    |
  | where  id_card=620321199201143724 |                                                              | 0x7D 4E    |



### B+树 和 Hash 表对比

- 实际开发中，B+树的使用场景非常之多，绝大部分都使用 B+树

> **Hash 表的查询效率非常之高，为什么不用 Hash 表呢？**
>
> - 因为 Hash 表只能做等值判断（这里的 Hash 等值判断包括：=，in()，<=>），如果是 `select * from sys_user where age>20;` 这种范围查询，Hash 表是做不到快速查询的，而 B+树的叶子结点上不但保存了数据，还保存了下一结点的地址，而且是双向的，我们只要查询到 age = 20 的数据，然后直接向右查找即可。
> - 存储的数据是没有顺序的，在 order by 情况下，需要重新排序
> - 联合索引，Hash 是对联合索引键合并之后计算的，无法对单独的键进行索引查询
> - 如果索引列重复值很多，效率很低，比如性别，hash 只有 男，女2种情况。



## 二叉树

| id（学号） | name（姓名） | rank（排名） | desc（描述） |
| :--------: | :----------: | :----------: | :----------: |
|     1      |     牛大     |      34      |              |
|     2      |     王二     |      77      |              |
|     3      |     张三     |      5       |              |
|     4      |     李四     |      91      |              |
|     5      |     赵五     |      22      |              |
|     6      |     劳六     |      89      |              |
|     7      |     田七     |      23      |              |
|     8      |     苟八     |      13      |              |
|    ...     |     ...      |     ...      |     ...      |

**如果我们对 rank 这一列加了索引**，假设是如下的二叉树，查询 89 只需要 4 次，查询 23 也只需要 4 次，复杂度为 O(log~2~n)。[在线二叉树](https://www.cs.usfca.edu/~galles/visualization/BST.html)

![image-20220705073205862](https://attach.blog.wen7.online/20230312162428.png)

> 为什么复杂度是 log~2~n？
>
> 现在玩一个游戏，随机写一个数字 1-16 之间，然后让你猜数。你要怎么猜？
>
> 方式一：1、2、3、4、5 ...... 按顺序猜，这个复杂度就是 O(n)，让你猜 64 个数，你可能需要 64 次才能猜中
>
> 方式二：二分法，先猜 8，因为二叉树的左边都比该数小，右边都比该数大，然后再猜 12，再猜 14，再猜 15，最多 4 次，2^4^=16，也就是 log~2~16=log~2~2^4^=4
>
> ![image-20230312162328369](https://attach.blog.wen7.online/20230312162329.png)



如果索引使用二叉树，那么**对 id 进行加索引**的话，就会变成如下，二叉树退化成链表，相当于还是全表扫描，还需要做额外的索引的操作和空间。

![image-20220705073600899](https://attach.blog.wen7.online/20220705073600.png)

所以我们要对该树（链表）进行平衡，得到如下红黑树，[在线红黑树](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html) 在插入数据时可以调低速度查看平衡过程。

![image-20220705074335027](https://attach.blog.wen7.online/20220705074335.png)

![image-20220705223240335](https://attach.blog.wen7.online/20220705223240.png)

红黑树已经比较好的能够对某一列加索引了，但是效率还是不够高。

因为假设有 1000 万行的数据，估算一下 log~2~1000万 = 深度，2^23^=8388608 , 2^24^=16777216 大概的深度为 23 - 24 左右，那么查询一个数的查询次数大概在 24 次左右。一个数就进行 24次的磁盘 I/O，效率很差。



平衡树（AVL树）
---

AVL树是一种自平衡二叉搜索树，它的平衡是通过旋转操作来实现的。

AVL树的特点是任何节点的左右子树的高度差都不超过1，这种平衡性可以保证AVL树的查找、插入和删除操作的时间复杂度都是O(log n)。 在AVL树中，每个节点都有一个平衡因子，它等于该节点的左子树高度减去右子树高度的差值。当插入或删除一个节点后，如果某个节点的平衡因子的绝对值大于1，就需要进行旋转操作来调整平衡。 

- 优点是保证了树的平衡性，因此在查找、插入和删除操作的时间复杂度上都比较稳定
- 缺点是由于需要频繁进行旋转操作，因此在插入和删除操作时可能会比较耗时
- 总的来说，AVL树是一种比较常用的自平衡二叉搜索树，在需要保证树的平衡性的场合下，可以考虑使用AVL树。

平衡二叉树

![image-20230312170810284](https://attach.blog.wen7.online/20230312170811.png)

平衡三叉树

![image-20230312214325685](https://attach.blog.wen7.online/20230312214326.png)

二叉树需要 5 层才能存下 30 个节点（1+2+4+8+16=31），三叉树只需要 4 层即可存下 40 个节点（1+3+9+27=40），相同的个数，三叉树的层数要明显小于二叉树，假设我们要找的数据都是在最后一个结点，二叉树需要读取 5 次数据页，而三叉树只需要读取 4 次数据页（而且同样层数三叉树存储的数据要比二叉树多）

当数据量比较大的时候，分叉的叉树比较大的时候，M 叉树高度会远远小于 二叉树，我们需要将树从 ==瘦高==变成==矮胖==，这样就能减少寻址次数（减少读取数据页次数）



## B 树

![image-20230312231104382](https://attach.blog.wen7.online/20230312231107.png)

节点里的数据从小到大，比如 8 < 12，

节点的子结点仍然尊重从小到大递增，并且按照父节点的顺序分散，比如 8 左边子结点的比 8 小（2 < 6 < 8），8 右边的子结点比 8 大（8 < 9 < 11 < 12）

==每个结点都存储数据==



## B+ 树

B+ 树适合文件索引系统，非常多 DBMS 都支持 B+ 树索引方式

<img src="https://attach.blog.wen7.online/20230312114529.png" alt="image-20220706000949682" style="zoom:80%;" />

所有数据都在叶子结点，非叶子结点冗余保存主键



### B+树和B树对比

==B树在所有结点都存储数据，B+树只在叶子结点存储数据==

==B+ 树查询效率更高==，因为B+树只有叶子结点存储数据，非叶子结点只存储主键，所以每个数据页可以存放的主键数量更多，所以B+树的阶数更大，深度更低，这样查询磁盘IO次数会比 B树少

==B+ 树范围查询效率高==，因为所有数据都在 B+ 树的叶子结点上，叶子结点单调递增（同一个数据页单链表，不同数据页双链表），可以通过指针连接范围查找，而B树需要进行中序遍历才能够范围查找。





















