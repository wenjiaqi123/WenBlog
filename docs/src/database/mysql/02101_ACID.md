ACID
===

[百度百科 - 事务](https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882)

ACID
---

- Atomicity【原子性】
- Consistency【一致性】
- Isolation【隔离性】
- Durability【持久性】

事务通过 ACID 四种特性来保证。



原子性 Atomicity
---

原子性：==一个事务是一个不可分割的工作单位，事务中包括的操作要么全部成功，要么全部失败，不允许成功一个，失败一个==



一致性 Consistency
---

一致性：==事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行前和执行后，数据库必须处于一致性状态==

其实原子性，隔离性，持久性都是为了保证一致性，即数据在一次事务执行前和执行后，处于一致性状态。



隔离性 Isolation
---

隔离性：==并发环境中，并发事务是隔离的，一个事务的执行不能被其他事务所干扰，，不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间==

当单线程的时候，是不会涉及到隔离性的，在并发环境下，多个事务同时发生，会出现以下问题：

- 脏读
- 丢失修改
- 不可重复读
- 幻读



针对以上会出现的并发问题，隔离性有4个级别，根据不同场景设置不同隔离级别：

- 读未提交（未授权读取）(Read-UnCommited)
- 读已提交（授权读取）（Read-Commited）
- 可重复读取（Repeatable-Read）
- 串行化（Serializable）

### 读未提交

读未提交：允许读到另外一个线程没有提交的事务。

可能会脏读，幻读，不可重复读，隔离级别最低



### 读已提交

读已提交：允许读取事务已经提交的数据。

可以阻止脏读，但是有可能发生 丢失修改，不可重复读和幻读。

![image-20220628142140046](https://attach.blog.wen7.online/image-20220628142140046.png)

假设两个线程的执行顺序如下

1. A 线程开启事务
2. B 线程开启事务
3. A 线程执行 SQL 语句1，查询了张三的余额为 1000【A线程第一次读】
4. B 线程执行 SQL 语句1，查询了张三的余额为 1000
5. B 线程执行 SQL 语句2，查询了李四的余额为 1000
6. B 线程执行 SQL 语句3，给张三的余额减300，此时余额为 700
7. B 线程执行 SQL 语句4，给李四的余额加300，此时余额为 1300
8. B 线程提交。
9. A 线程执行 SQL 语句2，查询了张三的余额为 700，读到了 B 线程已提交的数据【A线程第二次读】

==A 线程读取到了 B 线程已经提交的数据，A 的多次读取不一致，发生不可重复读==



### 可重复读取（默认）

可重复读取：多次读取同一个数据，值是一致的，除非是被自身修改。

如果阻止脏读，不可重复读，但是有可能出现幻读。



### 串行化

串行化：所有事务都被串行执行，事务只能一个接一个处理，不能并发执行。

可以防止脏读，不可重复读，幻读





| 隔离级别 |  脏读  | 丢失修改 | 不可重复读 |  幻读  |
| :------: | :----: | :------: | :--------: | :----: |
| 读未提交 | 会出现 |  会出现  |   会出现   | 会出现 |
| 读已提交 | 不允许 |  会出现  |   会出现   | 会出现 |
| 可重复读 | 不允许 |  不允许  |   不允许   | 会出现 |
|  串行化  | 不允许 |  不允许  |   不允许   | 不允许 |



|  并发问题  | 读未提交 | 读已提交 | 可重复度 | 串行化 |
| :--------: | :------: | :------: | :------: | :----: |
|    脏读    |    √     |    ×     |    x     |   x    |
|  丢失修改  |    √     |    √     |    x     |   x    |
| 不可重复读 |    √     |    √     |    x     |   x    |
|    幻读    |    √     |    √     |    √     |   x    |



持久性 Durability
---

持久性：==一个事务一旦提交，数据库中的状态应该是永久性的，一个事务一旦成功，新数据应该被永久保存==





如何保证
---

- MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的 **持久性**，使用 **undo log(回滚日志)** 来保证事务的 **原子性**。
- MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。
- 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。
