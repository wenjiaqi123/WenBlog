# InnoDB 的索引 B+树

## 前言

### 数据页

假设拿一张 A4 纸，在上面写数字，每一张 A4 纸上写 1000 个数字，这些数字按照从小到大排列，但不一定需要是连续的，类似下图

![image-20230311192936505](https://attach.blog.wen7.online/20230311192939.png)

如果写不下了，就再拿一张 A4 纸，继续往下写，类似下图

![image-20230311193038747](https://attach.blog.wen7.online/20230311193040.png)

如果我们想找到一个数字，比如 2874，我们应该怎么去查找呢？

显而易见，应该去第三张 A4 纸上去查找，因为 2874 > 2450（第三张纸上最小的值），但是如果是机器去查找，程序怎么知道去第三张纸上查找呢？

程序只能先去第一张纸上查看最小值，然后再去第二张纸上看最小值，再去第三张纸上看最小值，然后找到第三张，

我们需要保存每张纸上最小的值，然后将这些最小值再记录到另外一张目录页上，类似新华字典。

假设我们想找的数字是 1314520，那么程序要从第一张，第二张，第三张，估计得找个几十次，因为这个数字有点大，很明显在很后面的 A4 纸上

**这里的 A4 纸就是 MySQL 中的数据页，而每一次查找 A4 纸，相当于将数据页从硬盘读取到内存中，这个操作是很耗时的**



### 目录页

于是我们为了快速查找某一个数字，我们决定橙色 A4 纸来编一个目录，以下**绿色的写数字的 A4 纸就称为 数据页，写目录的橙色 A4 纸称为 目录页**

**特别说明：==这里的目录页和数据页在 MySQL 里都称为数据页==，但是为了讲解方便，写数据的称为数据页，写目录的称为目录页**

![image-20230311194033713](https://attach.blog.wen7.online/20230311194036.png)

我们讲每张数据页的最小值，和这张数据页的地址，写到目录页上去，如图所示

第一张数据页最小值为 1，数据页地址为 数据页2，目录页最多也只能写 1000 条数据，如果数据页的页数超过 1000 张，那么就需要 2 张目录页来记录，

**这个时候再查找数字 1314520，我们将目录页 27 加载到内存，然后就根据该目录页上的数据来判断，在哪一张数据页上，根据数据页地址，再加载具体的数据页到内存**

上述操作，仅仅加载了 2 次数据页，第一次为加载目录页27，第二次为加载数据页xxx

问题又来了，如果是查询数字 131452088，很显然，即使在目录页上查找，也需要先查目录页 27，再查目录页 45，再查目录页 xx，得先查个几十次目录页才能找到



### B+ 树

于是，我们对目录页再做目录页

![image-20230311202631034](https://attach.blog.wen7.online/20230311202635.png)

我们先预估一个数量级，我们把上图第一行（目录页93）称为第一层目录页，第二行（目录页27、目录页45）称为第二层目录页

一页数据页可以存储数据 1000个，那么一页第二层目录页，存储1000个数据页，就是 1000 x 1000= 1,000,000（一百万），一个第一层的目录页可以存储 1000 x 1000 x 1000 = 十亿

如果是查询数字 131452088 ，在目录页 93 上，先查找第一层目录页，再查找第二层目录页，再查找第三层数据页，

==仅仅加载了三次数据页，就能找到该数字==

![image-20230311204533542](https://attach.blog.wen7.online/20230311204535.png)

==上图这种结构就是 B+ 树==



## InnoDB 索引

上述案例只是为了方便理解 B+ 树，有一些地方是不合理，或者术语不正确的，或者没有讲解到位的，这里统一进行整理一下

### 数据页

数据页和目录页只是为了讲解方便，==在 MySQL 里统一称为数据页==。

- 一个数据页为 16 KB，16K x 1024 = 16384 Byte

  - ```mysql
    show global status 
    like 'Innodb_page_size';
    ```

  ![image-20220705225631114](https://attach.blog.wen7.online/20230311205250.png)
  
  

### 索引即数据

叶子结点（最下面的数据页）是存储的实际数据
- 比如一行记录（id:1，name:张三，age:18，address:江苏）这一条记录的大小是根据业务表来确定的
  - 如果一条记录大小为 1 KB（1024字节），那么最下面的数据页，一页只能存放 16/1 = 16 条数据
  - 如果一条记录大小为 2 KB，那么一页只能存放 16/2=8 条数据
  - **先预告一下，实际 MySQL 并不会在一个数据页插入得满满当当，而是会留下 1/16 的空间**
  
  <img src="https://attach.blog.wen7.online/20230312114529.png" alt="image-20220706000949682" style="zoom:80%;" />
  
  假设该列设置的类型是 bigint(8字节) + 指针(6字节)=14个字节，那么一个节点就可以存储 16384/14=1170 个索引，那么两层索引就可以存储 1170*1170=1368900 个索引
  
  假设该列设置的类型是 int(4字节) + 指针(6字节) = 10 字节，那么一个节点就可以存储 16384/10=1638 个索引，那么两层索引就可以存储 1638*1638= 2683044 个索引
  
  假设叶子结点，索引 + 数据 = 1KB，那么一个节点就可以存储 16KB/1KB = 16个数据
  
  1368900*16=21902400（2190万）
  
  2683044*16=42928704（4292万）
  
  只要三层就可以存储千万级别的数据，只要经过3次磁盘 IO。
  
  

### 行记录

如图，假设用户表中存储，id，name，age，但是在底层，MySQL  对一行数据其添加了其他的一些字段，比如 record_type、next_record

![image-20230311211353038](https://attach.blog.wen7.online/20230802134358.png)

- ==record_type==：表示记录类型，0 表示普通记录，1 表示目录页，2表示最小记录，3表示最大记录

- ==next_type==：表示下一条地址相对于本条记录的偏移量



#### 数据页业务记录

数据页里最小值 record_type = 2，最大值 record_type = 3，普通记录 record_type = 0

next_type 指向下一条记录

<img src="https://attach.blog.wen7.online/20230311213258.png" alt="image-20230311213257130" style="zoom:80%;" />

<img src="https://attach.blog.wen7.online/20230311213302.png" alt="image-20230311213246906" style="zoom:80%;" />

#### 数据页目录

如果 record_type = 1 ，表示这其实是个目录，所以 MySQL 中知道数据页里存的到底是目录，还是数据

<img src="https://attach.blog.wen7.online/20230311213748.png" alt="image-20230311213743933" style="zoom:80%;" />

#### 链表连接

==数据页内按照主键大小排序使用单向链表==

==数据页与数据页之间，使用双向链表==

![image-20230513122047758](https://attach.blog.wen7.online/20230513122049.png)



### 聚集索引（聚簇索引）

![image-20230311204533542](https://attach.blog.wen7.online/20230311215337.png)

- 如上图所示，叶子结点存储数据，其他结点存储索引，这种结构就称为 ==聚簇索引==

- 优点

  - **数据访问快**，因为索引和数据在同一个树中

  - 对于主键的 **排序查找** 和 **范围查找** 非常快

- 缺点
  - **插入速度依赖于插入顺序**，一般业务开发都会设置主键递增，按序插入是最快的，不然会出现页分裂
  - **更新主键代价高**，如果主键更新，会移动行记录
  - **二级索引需要两次查找**，第一次找到主键值，第二次按照主键查找



### 非聚集索引（非聚簇索引，二级索引，辅助索引）

<img src="https://attach.blog.wen7.online/20230311220931.png" alt="image-20230311220929778" style="zoom:80%;" />

比如现在对年龄作为搜索条件进行查找，肯定不可能一条一条记录的查找，我们可以对年龄字段创建 B+树，如上图所示

只不过这里的键是年龄，数据是那条记录对应的主键值

查找时，按照年龄 B+树先查找到 18 岁的记录，记录主键为 1、1221，然后再去查找主键1、主键1221 的数据，这个操作也称为 ==回表==

==一张表只能有一个聚簇索引，但是可以有多个非聚簇索引==

> 为什么不在年龄的 B+ 树的里存储用户数据，而是只存放主键呢？
>
> 如果用户数据很多，重复存储，浪费存储空间

> 非聚集索引一定会回表吗？
>
> 不一定，比如 `select age from sys_user where age<18` 这种情况，我们只查询 age 字段，而且 age 字段做了索引，那么就不需要回表！



### 根页不变

上述 A4 纸案例是为了方便理解 B+树，但是实际上，**B+树的创建是自顶向下的**

- 在第一个数据页（==根页==）中，存放数据，1、2、3...... 直到 1000（假设一个数据页还是放 1000 条数据），该数据页放满，当再插入一个数字 1001 时
- 会开辟2个新数据页（称为数据页 a，和数据页 b），将根页里的数据（1-1000）复制到该数据页 a，将 1001 放到数据页 b，将 ==根页== 里的内容升级为数据页 a 和数据页 b 的地址，这样就保证了 ==根数据页位置不会变化==
- 创建一个 B+ 树，就会多一个根页，该页的页号会被记录，以后访问就从该页来访问索引



### 联合索引

实际业务中，可能要按照不止一列来排列查找，可能需要按照 **年龄** 和 **身高** 2列进行查找

先按照 年龄 创建 B+ 树，在此基础上，年龄相同的，按照 身高 进行排序

按照 年龄 和 身高 大小的排序规则建立的 B+ 树称为 ==联合索引==

那这里的联合索引就有3列数据，一列是 年龄，一列是 身高，还有一列是主键

<img src="https://attach.blog.wen7.online/20230311222709.png" alt="image-20230311222708240" style="zoom:80%;" />



### 目录页内节点唯一性

假设按照年龄建索引（虽然实际业务中可能不会按照年龄建索引，只是为了举例），因为年龄的分布比较密集，18岁的人很多，18 的索引可能分布在数据页2、数据页98、数据页74 上，当查询目录页27的时候，并不能很好的找出 18 应该查询哪一个数据页。

需要对目录页的内节点，还要额外添加主键列。保证目录页内节点除了页号以外，保持唯一。

![image-20230513130724857](https://attach.blog.wen7.online/20230513130726.png)



## 索引设计

- 不应当使用过长字段作为主键：如果主键过长，一个数据页能存放的节点数就会变少
- 最好使用单调递增字段作为主键：如果不是单调递增的，类似 UUID 这种的，插入新数据的时候为了维持 B+树的特性，会频繁进行页分裂调整，十分低效。























































